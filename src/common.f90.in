module common_mod

  @USE_FFTW@
  @USE_GPFA@
  use options
  use constants


  implicit none

  public

  save

  type(options_t) :: opts 

  character(len=100), parameter ::  VERSION="GGADT (General Geometry Anomalous Diffraction Theory) v@PACKAGE_VERSION@"
  character(len=100), parameter ::  INFO = "Written by John Hoffman (jah5@princeton.edu)&
    & and Michael Tarczon (mtarczon@princeton.edu)"

  complex(kind=dp_complex)               ::  delm 
  
  real(dp_real)                          ::  a_eff     
  real(dp_real)                          ::  ephot 

  character(len=50)                      ::  geometry  
  character(len=50)                      ::  angle_mode
  character(len=50)                      ::  rotation_axis




  integer                                ::  ngrain
  integer                                ::  nscatter_min 
  integer                                ::  ngrid
  integer                                ::  nscatter
  integer                                ::  norientations 
  integer                                ::  ierr

  real(dp_real)                          ::  grid_width  
  real(dp_real)                          ::  dtheta
  real(dp_real)                          ::  ior_im        
  real(dp_real)                          ::  ior_re     
  real(dp_real), dimension(3)            ::  grain_a 
  real(dp_real)                          ::  max_angle

  logical                                ::  use_padded_fft
  logical                                ::  use_efficiencies
  logical                                ::  asked_for_version
  logical                                ::  asked_for_help
  logical                                ::  verbose_mode
  logical                                ::  timing_mode
  logical                                ::  material_file_specified
  logical                                ::  force_numerical
  character(len=200)                     ::  parameter_file_name


! new variables
  integer                                ::  nephots
  real(dp_real)                          ::  ephot_min
  real(dp_real)                          ::  dephot
  real(dp_real)                          ::  ephot_max 
 !character(len=200)                     ::  material          ! name of predefined material
  character(len=200)                     ::  material_file     ! file that defines ior_re and ior_im for a range of energies
  logical                                ::  integrated_mode          
                                                              
!-------

  character(len=200), dimension(max_num_mats)           ::  material_files
  character(len=200), dimension(max_num_mats)           ::  material_tags
  character(len=200)                                    ::  agglom_composition_file
  character(len=200)                                    ::  axes_convention
  integer, allocatable                                  ::  agglom_material_tags(:)
  integer                                               ::  nmaterials
  real(dp_real), dimension(max_num_mats)                ::  matfracs
  real(dp_real), dimension(max_num_mats)                ::  ior_res_single_en
  real(dp_real), dimension(max_num_mats)                ::  ior_ims_single_en



  character(len=200)                                    ::  angle_file
  character(len=100)                                    ::  fftw_optimization_mode_name
  character(len=200)                                    ::  agglom_file_name

  integer :: rank_aeff, rank_grain_a1, rank_grain_a2, rank_grain_a3, &
         rank_ephot, rank_use_padded_fft, rank_force_numerical, &
         rank_integrated_mode, rank_use_efficiencies, rank_verbose_mode, &
         rank_timing_mode, rank_ior_re, rank_ior_im, rank_geometry, rank_angle_mode, &
         rank_rotation_axis, rank_angle_file, rank_ngrain, rank_nscatter, &
         rank_norientations, rank_dtheta, rank_max_angle, rank_agglom_file_name, &
         rank_fftw_optimization_mode_name, rank_ephot_min, rank_ephot_max, rank_nephots, &
         rank_dephot, rank_material_files(max_num_mats), rank_material_tags(max_num_mats), &
         rank_agglom_composition_file, rank_material_file, rank_asked_for_version, &
         rank_asked_for_help, rank_parameter_file_name, rank_axes_convention

  contains



    subroutine set_parameter_values()
      implicit none
      character(len=100) :: optname
      integer :: i
     

      call define_flag(opts,"help",abbrev='h',description="Print this help message.")
      call define_flag(opts, &
        "version",abbrev='v',&
        description="Print version information")
      call define_flag(opts, &
        "verbose",abbrev='d',&
        description="prints variable values and other status messages")
      call define_flag(opts, &
        "use-efficiencies",abbrev='e',&
        description="use dimensionless cross sections (efficiencies): Q = sigma/(pi*aeff^2)")
      call define_flag(opts, &
        "timing",abbrev='t',&
        description="suppresses output for timing purposes")
      call define_flag(opts, &
        "integrated",&
        description="Generates integrated cross sections (scattering, absorption and extinction) as a function of photon energy")
      call define_flag(opts, &
        "force-numerical",&
        description="Forces GGADT to use a numerical, rather than an analytical, solution for spherical grains.")
      call define_option_string(opts,&
        "parameter-file","",&
        description="Path to parameter file")


      ! Allow user to specify up to max_num_mats materials:

      do i=1,max_num_mats
        if (i .gt. 10) then 
          write(optname,'(i2)') i 
        else
          write(optname,'(i1)') i 
        end if 
        
        call define_option_string(opts,&
          "material-file"//optname,"",&
          description="Path to material file for material "//optname)
        call define_option_string(opts,&
          "material-tag"//optname,"",&
           description="Tag to associate with material "//optname)
        !call define_option_real(opts,&
       !  "material-frac"//optname,"",&
       !  description="Volume fraction of the grain composed of material "//optname)
      end do 
      

      call define_option_string(opts,&
        "agglom-composition-file","",&
        description="File matching each agglomerate with a material tag")



      call define_option_string(opts,&
        "grain-geometry",default_grain_geometry,&
        description="SPHERES (or AGGLOMERATION), ELLIPSOID, SPHERE, or CUSTOM")
      call define_option_string(opts,&
        "agglom-file",default_agglom_file_name,&
        description="Path to file that defines agglomeration of spheres")

      call define_option_real(opts,&
        "aeff",default_aeff,&
        description="Effective radius of grain")
      call define_option_real(opts,&
        "grain-axis-x",default_grain_a1,&
        description="For ELLIPSOID grains: x-axis length")
      call define_option_real(opts,&
        "grain-axis-y", default_grain_a2,&
        description="For ELLIPSOID grains: y-axis length")
      call define_option_real(opts,&
        "grain-axis-z", default_grain_a3,&
        description="For ELLIPSOID grains: z-axis length")
      call define_option_real(opts,&
        "ephot",default_ephot,&
        description="Energy of X-ray photon in keV")
      call define_option_real(opts,&
        "max-angle",default_max_angle,&
        description="Maximum scattering angle in arcseconds")
      call define_option_real(opts,&
        "ior-re",default_ior_re,&
        description="real(dp_real) component of the index of refraction, minus 1")
      call define_option_real(opts,&
        "ior-im",default_ior_im,&
        description="Imaginary component of the index of refraction")
      call define_option_real(opts,&
        "dtheta",default_dtheta, &
        description="Angular resolution for dQscatter/dOmega calculation")
      call define_option_integer(opts,&
        "ngrain",default_ngrain,&
        description="Number of grid points along 1 dimension with which we should resolve the grain")
      call define_option_integer(opts,&
        "nscatter",default_nscatter,&
        description="Number of angles along 1 dimension with which we should calculate the scattering cross section")
      call define_option_integer(opts,&
        "norientations",default_norientations,&
        description="Number of orientations to average over")
      call define_option_string(opts,&
        "angle-mode",default_angle_mode,&
        description="How to choose Euler angles (sequential, random, file)")
      call define_option_string(opts,&
        "rotation-axis",default_rotation_axis,&
        description="Sampled orientations will be rotations about this axis (none, xaxis, yaxis, zaxis)")

      call define_option_string(opts,&
        "axes-convention",default_axes_convention,&
        description="'ddscat' (beta,theta,phi) or 'mstm' (alpha,beta,gamma). See documentation for more details.")


      call define_option_string(opts,&
        "angle-file",default_angle_file,&
        description="Path to a text file containing a list of orientations")
      


      call define_option_real(opts,&
        "ephot-min", default_ephot_min,&
        description="Minimum photon energy for which to calculate the cross sections")
      call define_option_real(opts,&
        "ephot-max", default_ephot_max,&
        description="Maximum photon energy for which to calculate the cross sections")
      call define_option_integer(opts,&
        "nephots", default_nephots,&
        description="Number of photon energies for which to calculate integrated cross sections")
      call define_option_real(opts,&
        "dephot", default_dephot,&
        description="Spacing between photon energies")
      
      call define_option_string(opts,&
        "material", default_material,&
        description="Name of material (this will be obselete in future versions). Must be --material='custom'")
      call define_option_string(opts,&
        "material-file", default_material_file,&
        description="Path to file providing energy dependent indices of refraction and &
                  &dielectric constant for the grain material")

      call define_option_string(opts,"fftw-optimization",default_fftw_opt_name,required=.false.,&
        description="[estimate,measure,patient,exhaustive]")
      call define_flag(opts,"use-padded-fft",&
        description="Use a slower FFT method that pads a &
        &2d grid to obtain more points in the desired range of scattering angles. &
        &This should only be used for consistency tests.")

      ! First read in defaults
      call process_input_file(opts,defaults_file_name,ierr,delim_char="=",rank=3)
      if (ierr .ne. 0) then
        write(stderr,*) "ERROR: Cannot read '",trim(defaults_file_name),"'. Quitting."
        stop
      end if 

      ! write(0,*) "Loaded defaults."

      ! Now process command line options in order to read
      call process_command_line(opts,ierr,rank=1)
      if (ierr .ne. 0) then
        write (stderr,*) "ERROR in processing command line arguments." 
        stop
      end if
      ! write(stderr,*) "Processed command line arguments (round 1 of 2)."
      
      ! Read parameter file if one is given (overwrite everything)
      call get_option_string(opts,"parameter-file",parameter_file_name,rank_parameter_file_name)
      if (parameter_file_name .ne. "") then
        call process_input_file(opts,parameter_file_name,ierr,delim_char="=",overwrite="YES",rank=2)
        ! write(stderr,*) "Processed parameter file."
        if (ierr .ne. 0) then
          write(stderr,*) "ERROR: Cannot read ",parameter_file_name,". Quitting."
          stop
        end if 
      end if

      ! re-read command line arguments (to overwrite parameter file arguments)
      call process_command_line(opts,ierr,rank=1)
      ! write(stderr,*) "Processed command line arguments (round 2 of 2)."
      if (ierr .ne. 0) then
        write (stderr,*) "ERROR in processing command line arguments." 
        stop
      end if
      




      ! Set values
      call get_option_real(opts,"aeff",a_eff,rank_aeff)
      call get_option_real(opts,"grain-axis-x",grain_a(1),rank_grain_a1)
      call get_option_real(opts,"grain-axis-y",grain_a(2),rank_grain_a2)
      call get_option_real(opts,"grain-axis-z",grain_a(3),rank_grain_a3)
      call get_option_real(opts,"ephot",ephot,rank_ephot)
      call get_flag(opts,"use-padded-fft",use_padded_fft,rank_use_padded_fft)
      call get_flag(opts,"force-numerical",force_numerical,rank_force_numerical)
      call get_flag(opts,"integrated",integrated_mode, rank_integrated_mode) 
      call get_flag(opts,"use-efficiencies",use_efficiencies, rank_use_efficiencies)  
      call get_flag(opts,"verbose",verbose_mode, rank_verbose_mode)
      call get_flag(opts,"timing",timing_mode, rank_timing_mode)
      call get_option_real(opts,"ior-re",ior_re, rank_ior_re)
      call get_option_real(opts,"ior-im",ior_im, rank_ior_im)

      call get_option_string(opts,"grain-geometry",geometry, rank_geometry)
      call get_option_string(opts,"axes-convention",axes_convention, rank_axes_convention)
      call get_option_string(opts,"angle-mode",angle_mode, rank_angle_mode)
      call get_option_string(opts,"rotation-axis",rotation_axis, rank_rotation_axis)
      call get_option_string(opts,"angle-file",angle_file, rank_angle_file)
      call get_option_integer(opts,"ngrain",ngrain, rank_ngrain)
      
      call get_option_integer(opts,"nscatter",nscatter, rank_nscatter)
      call get_option_integer(opts,"norientations",norientations, rank_norientations)
      call get_option_real(opts, "dtheta", dtheta, rank_dtheta)
      call get_option_real(opts,"max-angle",max_angle, rank_max_angle)
      call get_option_string(opts,"agglom-file",agglom_file_name, rank_agglom_file_name)
      call get_option_string(opts,"fftw-optimization",fftw_optimization_mode_name, rank_fftw_optimization_mode_name)

      call get_option_real(opts,"ephot-min", ephot_min, rank_ephot_min)
      call get_option_real(opts,"ephot-max", ephot_max, rank_ephot_max)
      call get_option_integer(opts,"nephots", nephots, rank_nephots)
      call get_option_real(opts,"dephot", dephot, rank_dephot)

      do i=1,max_num_mats
        if (i .gt. 10) then
          write(optname,'(i2)') i 
        else
          write(optname,'(i1)') i 
        end if 
        
        call get_option_string(opts,"material-file"//optname,material_files(i), rank_material_files(i))
        call get_option_string(opts,"material-tag"//optname,material_tags(i), rank_material_tags(i))

      end do 

      call get_option_string(opts,"agglom-composition-file",agglom_composition_file, rank_agglom_composition_file)
      call get_option_string(opts,"material-file",material_file, rank_material_file)
     
      call get_flag(opts,"version",asked_for_version,rank_asked_for_version)
      call get_flag(opts,"help",asked_for_help,rank_asked_for_help)


      if (asked_for_version) then
        write(stdout,*) VERSION
        write(stdout,*) INFO 
        stop
      end if
      if (asked_for_help) then
        call print_help(opts) 
      end if 

      delm = cmplx(ior_re,ior_im)

      ! Set to lower case
      fftw_optimization_mode_name = strlowcase(fftw_optimization_mode_name)
      angle_mode = strlowcase(angle_mode)
      rotation_axis = strlowcase(rotation_axis)
      geometry = strlowcase(geometry)
      axes_convention = strlowcase(axes_convention)

      material_file_specified = option_found(opts,"material-file")
      ! make sure all material files have a corresponding material tag and count number of materials
      nmaterials = 0
      
      do i=1,max_num_mats
        write(optname,'(I1)') i
        if (option_found(opts,"material-file"//optname) .and. .not. &
            option_found(opts,"material-tag"//optname) ) then
          write(stderr,*) "ERROR: material_tags(",i,") defined as '",&
              material_tags(i),"', but no corresponding material file defined."
          stop
        else if (option_found(opts,"material-tag"//optname) .and. .not. &
            option_found(opts,"material-file"//optname) ) then
          write(stderr,*) "ERROR: material_files(",i,") defined as '",&
              material_files(i),"', but no corresponding material tag defined."
          stop
        end if 
        
        if (option_found(opts,"material-file"//optname)) then
          material_file_specified = .TRUE.
          ! can't mix material-file and material-file1,2,... parameters
          if (option_found(opts,"material-file") .and. (rank_material_file .LE. rank_material_files(i))) then 
            write(stderr,*) "ERROR: Cannot use BOTH --material-file and --material-file1,2,.. options"
            stop
          end if 
          nmaterials = nmaterials + 1
        end if 
      end do

      ! if(material_file_specified) write(stderr,*) "material_file_specified..."

      if ( (option_found(opts,"ior-re") .or. option_found(opts,"ior-im")) .and. material_file_specified) then
        if (min(rank_ior_re,rank_ior_im) == min(rank_material_file,minval(rank_material_files))) then
          write(stderr,*) "Warning: you have specified BOTH a manual index of refraction value and "
          write(stderr,*) "   a material file. We will use the material file by default."
        else if (min(rank_ior_re,rank_ior_im) < min(rank_material_file,minval(rank_material_files))) then 
          material_file_specified = .FALSE.
        end if 
      end if 
     

      ! If multiple compositions specified, but the grain isn't an agglomerate
      if ( nmaterials .gt. 0 .and. .not. (geometry == "spheres" .or. geometry == "agglomerate")) then
        write(stderr,*) "Warning: you have specified more than one material file, but the grain"
        write(stderr,*) "  geometry is ",geometry," not 'spheres'/'agglomerate'. Multiple compositions is"
        write(stderr,*) "  currently only supported for agglomerate grains."
      end if 
      ! check that the user didn't forget to provide the agglom-composition-file
      if ( nmaterials .gt. 0 .and. .not. option_found(opts,"agglom-composition-file")) then
        write(stderr, *) "ERROR: agglom-composition-file parameter is not set, but material-file1 and material-tag1 are."
        stop
      end if 
      
      ! Some book keeping if we're just using a single composition
      if (nmaterials == 0 .and. material_file_specified) then 
        material_files(1) = material_file 
        nmaterials = 1
      else if (nmaterials == 0) then
        ! Otherwise use manually supplied index of refraction
        ! write(stderr,*) "manual ior..."
        material_file_specified = .FALSE.
        material_files(1) = ""
        material_file = ""
        nmaterials = 1

      end if 




      ! Resolve parameter conflicts


      ! nscatter and dtheta
      if (option_found(opts,"nscatter") .and. option_found(opts, "dtheta")) then
        if (rank_nscatter == rank_dtheta) then
          write(stderr,*) "Warning: You have specified BOTH the 'nscatter' and 'dtheta' options."
          write(stderr,*) "We will use your specified value of nscatter:", nscatter
        else if (rank_dtheta < rank_nscatter .or. rank_nscatter == 4) then
          nscatter = int(ceiling(real(2*max_angle,dp_real)/dtheta))
        end if
      else if (option_found(opts,"dtheta")) then
          nscatter = int(ceiling(real(2*max_angle,dp_real)/dtheta))
      end if 

      ! nephots and dephot
      if (option_found(opts,"dephot") .and. option_found(opts, "nephots")) then
        if (rank_dephot == rank_nephots) then
          write(stderr,*) "Warning: You have specified BOTH the 'nephots' and 'dephot' options."
          write(stderr,*) "We will use your specified value of nephots:", nephots
        else if (rank_dephot < rank_nephots .or. rank_nephots == 4) then 
          nephots = int(ceiling((ephot_max - ephot_min)/dephot))
        else 
          dephot = (ephot_max - ephot_min)/(nephots - 1)
        end if 
      else if (option_found(opts,"dephot")) then
          nephots = int(ceiling((ephot_max - ephot_min)/dephot))
      else 
          dephot = (ephot_max - ephot_min)/(nephots - 1)
      end if 

      ! If index of refraction is defined manually (ior-re and ior-im), and ephot/material-file
      ! options are also specified, go with the material file.
      if ((option_found(opts,"ephot") .and. option_found(opts,"material-file")) .and. &
            & (option_found(opts, "ior-re") .or. option_found(opts,"ior-im") )) then

          if (min(rank_ephot, rank_material_file) == min(rank_ior_re, rank_ior_im) .and. rank_ephot .lt. 4) then
            write(stderr,*) "Warning: You have specified BOTH 'ephot'/'material-file' and 'ior-re'/'ior-im' parameters."
            write(stderr,*) "We will pull the index of refraction value from material-file=",material_file
            write(stderr,*) "at a photon energy of ephot=",ephot,"keV."
          else if (min(rank_ior_re,rank_ior_im) < min(rank_ephot,rank_material_file)) then
            material_file_specified = .FALSE.
            material_file=""
            material_files(1)=""
          else 
            ior_re = 0.0
            ior_im = 0.0
          end if 
      end if 

      ! make sure the axes_convention is an allowable value

      if (.not. (axes_convention == 'ddscat' .or. axes_convention == 'mstm')) then
        write(stderr, *) "ERROR: '",axes_convention,"' is not one of 'ddscat' or 'mstm'"
        stop
      end if 


      ! TEMPORARY warning about rotation-axis option

      if (.not. (rotation_axis == 'none')) then
        write(stderr, *) "WARNING: the current implementation of the rotation-axis option is faulty."
        write(stderr, *) "    Future versions will have rotation and precession axis options."
      end if 
      if (.not. integrated_mode) then
          nephots = 1
          dephot = 0.0

          if (verbose_mode) then 
            write(stderr,*) "GGADT will now calculate the DIFFERENTIAL SCATTERING CROSS SECTION"
            write(stderr,*) "at a single energy for a single dust grain with a geometry of ", geometry
            write(stderr,*) ""
            write(stderr,*) "If instead you wish to calculate the energy dependent integrated cross sections,"
            write(stderr,*) "pass the '--integrated' flag (or set integrated=T in your parameter file)."
          end if
      else
         if (verbose_mode) then 
            write(stderr,*) "GGADT will now calculate the INTEGRATED (ABS,SCAT,EXT) CROSS SECTIONS"
            write(stderr,*) "for a single dust grain with a geometry of ", geometry
            write(stderr,*) "over the energy range ", ephot_min," - ",ephot_max, " keV in ",dephot," keV increments"
            write(stderr,*) "for a dust grain composed of ",nmaterials," materials:"
            do i=1,nmaterials
              write(stderr,*) " + ", material_files(i)

            end do
            write(stderr,*) 
            write(stderr,*) ""
            write(stderr,*) "If instead you wish to calculate the differential scattering cross section,"
            write(stderr,*) "do not pass the '--integrated' flag (or set integrated=F in your parameter file)."
          end if

      end if 

    end subroutine set_parameter_values

    subroutine print_help(opts)
      type(options_t), intent(in) :: opts
      write (*,'(a)') "ggadt: Computes orientationally averaged scattering and absorption&
        &quantities for a user-defined dust grain."
      write (*,'(a)') "Usage: ggadt [options]"
      write (*,'(a)') ""
      write (*,'(a)') "Options:"
      call print_options(opts)
      stop
    end subroutine print_help


    function rot_matrix(angles)
      ! Rotation matrix for a set of Euler angles -- for some reason this function does not work!
      ! (We use rot_x*rot_y*rot_z instead.) It's a low-priority bug.
      implicit none
      real(dp_real), dimension(3), intent(in) :: angles
      real(dp_real), dimension(3,3) :: rot_matrix
      rot_matrix(1,1) =  cos(angles(2))*cos(angles(3))
      rot_matrix(1,2) = -cos(angles(1))*sin(angles(3))-sin(angles(1))*sin(angles(2))*cos(angles(3))
      rot_matrix(1,3) =  sin(angles(1))*sin(angles(3))-cos(angles(1))*sin(angles(2))*sin(angles(3))

      rot_matrix(2,1) =  cos(angles(2))*sin(angles(3))
      rot_matrix(2,2) =  cos(angles(1))*cos(angles(3))-sin(angles(1))*sin(angles(2))*sin(angles(3))
      rot_matrix(2,3) = -sin(angles(1))*cos(angles(3))-cos(angles(1))*sin(angles(2))*sin(angles(3))

      rot_matrix(3,1) =  sin(angles(2))
      rot_matrix(3,2) =  sin(angles(1))*cos(angles(2))
      rot_matrix(3,3) =  cos(angles(1))*cos(angles(2))
    end function rot_matrix

    function rot_x(angles)
      implicit none
      real(dp_real), intent(in) :: angles
      real(dp_real), dimension(3,3) :: rot_x
      rot_x(1,1) = 1.0
      rot_x(1,2) = 0.0
      rot_x(1,3) = 0.0

      rot_x(2,1) =  0.0
      rot_x(2,2) =  cos(angles)
      rot_x(2,3) = -sin(angles)

      rot_x(3,1) =  0.0
      rot_x(3,2) =  sin(angles)
      rot_x(3,3) =  cos(angles)
    end function rot_x 

    function rot_y(angles)
      implicit none
      real(dp_real), intent(in) :: angles
      real(dp_real), dimension(3,3) :: rot_y
      rot_y(1,1) =  cos(angles)
      rot_y(1,2) =  0.0
      rot_y(1,3) =  sin(angles)

      rot_y(2,1) =  0.0
      rot_y(2,2) =  1.0
      rot_y(2,3) =  0.0

      rot_y(3,1) = -sin(angles)
      rot_y(3,2) =  0.0
      rot_y(3,3) =  cos(angles)
    end function rot_y

    function rot_z(angles)
      implicit none
      real(dp_real), intent(in) :: angles
      real(dp_real), dimension(3,3) :: rot_z
      rot_z(1,1) = cos(angles)
      rot_z(1,2) = sin(angles)
      rot_z(1,3) = 0.0

      rot_z(2,1) = -sin(angles)
      rot_z(2,2) =  cos(angles)
      rot_z(2,3) =  0.0

      rot_z(3,1) = 0.0
      rot_z(3,2) = 0.0
      rot_z(3,3) = 1.0
    end function rot_z

    
    function strlowcase(input_string) 
        character(*),parameter :: lower_case = 'abcdefghijklmnopqrstuvwxyz' 
        character(*),parameter :: upper_case =  'ABCDEFGHIJKLMNOPQRSTUVWXYZ'  
       ! -- argument and result
       character( * ), intent( in ) :: input_string
       character( len( input_string ) ) :: strlowcase
       ! -- local variables
       integer :: i, n

       ! -- copy input string
       strlowcase = input_string
       ! -- loop over string elements
       do i = 1, len(strlowcase)
         ! -- find location of letter in upper case constant string
         n = index( upper_case, strlowcase( i:i ) )
         ! -- if current substring is an upper case letter, make it lower case
         if ( n /= 0 ) strlowcase( i:i ) = lower_case( n:n )
       end do
    end function strlowcase 


    subroutine fft_faster(f,kmin,kmax,enhancement, fft_output)
        ! Performs an efficient series of FFT's to suit our needs
        ! Astrophysical applications of ADT for x-ray scattering of dust
        !   typically care about small angle scattering, which corresponds to
        !   small values of K in the fourier transform. To get better resolution,
        !   one can either pad the FFT, OR, one can do a series of off-set FFT's.
        !   The latter approach takes about a 10th of the time.
        
        integer, intent(in) :: kmin, kmax, enhancement
        
        complex(kind=dp_complex), intent(inout) :: f(:,:)
        complex(kind=dp_complex), intent(out) :: fft_output(:,:)
        complex(kind=dp_complex), allocatable :: working_fft(:,:)
        complex(kind=dp_complex), dimension(size(f(:,1)), size(f(1,:))) :: new_grid
        integer :: i,j,a,b,norig, fsize, fftsize, ix, iy
        real(dp_real) :: deltaz, deltay

        f = kspace_shift(f,real(kmin,dp_real),real(kmin,dp_real)) ! shift the input function so that the k-space origin is at (kmin,kmin)
        norig = kmax - kmin 
        fsize = size(f(:,1))
        fftsize = norig*enhancement + 1
        
        if (fftsize .ne. size(fft_output(1,:))) then
          write(stderr,*) "ERROR: (fft_faster) fft_output size is ",size(fft_output(1,:)),&
                          ", but fftsize = norig*enhancement + 1 = ",fftsize
          stop
        end if 

        if (fsize < norig) then
            write(stderr,*) "ERROR"
            write(stderr,*) "Your chosen value for ngrain is too low to obtain &
                    &high resolution features within the scattering region &
                    &that you've specified. &
                    &Choose an ngrain value of at least",norig
            stop
        end if 
        ! allocate memory
        allocate( working_fft(  norig   ,   norig   ))
        !allocate( fft_output(   fftsize ,   fftsize ))
        

        do i=1,enhancement+1
            deltaz = real(i-1)/real(enhancement)
            do j=1,enhancement+1
                deltay = real(j-1)/real(enhancement)
                new_grid = kspace_shift(f,deltaz,deltay)
                working_fft = fft_firstk(new_grid,norig)
                do a=1,norig
                    do b=1,norig
                        ix = i + (a-1)*enhancement
                        iy = j + (b-1)*enhancement
                        if ((ix <= fftsize) .and. (iy <= fftsize)) then
                            fft_output(ix, iy) = working_fft(a,b)
                        end if 
                    end do
                end do 
            end do
        end do 
          
        f = kspace_shift(f,real(-kmin,dp_real),real(-kmin,dp_real)) ! shift the input function back.
    end subroutine fft_faster

    function fft_center(f)
        complex(kind=dp_complex), intent(in) :: f(:,:)
        complex(kind=dp_complex), dimension(size(f(:,1)),size(f(1,:))) :: fft_center
        integer :: i, j, n

        n = size(f(:,1))
        do i=1,n
            do j=1,n
                fft_center(i,j) = f(i,j)*(-1)**(i+j)
            end do
        end do 
    end function fft_center

    function kspace_shift(f,shiftz,shifty)
        real(dp_real),  intent(in) :: shiftz,shifty
        complex(kind=dp_complex), intent(in) :: f(:,:)
        complex(kind=dp_complex), dimension(size(f(:,1)),size(f(1,:))) :: kspace_shift
        integer :: i, j, n

        n = size(f(:,1))

        do i=1,n
            do j=1,n
                kspace_shift(i,j) = f(i,j)*exp(ISIGN*CMPLX(0,1.0, kind=dp_complex)*twopi*(shiftz*(i-1)+shifty*(j-1))/real(n))
            end do
        end do
    end function kspace_shift


    

    subroutine convert_mstm_to_ddscat(angles)
     implicit none
     real(dp_real), dimension(3), intent(inout) :: angles
     real(dp_real), dimension(3) :: mstm

     mstm(:) = angles(:)

     if (cos(mstm(1))*sin(mstm(2)) == -1.) then 
      angles(1) = mstm(3)
      angles(2) = pi 
      angles(3) = pi/2.0
     else if (cos(mstm(1))*sin(mstm(2)) == 1.) then 
      angles(1) = -mstm(3)
      angles(2) = 0.0
      angles(3) = pi/2.0
     else 
      angles(2) = acos(cos(mstm(1))*sin(mstm(2)))
      angles(1) = acos(-sin(mstm(1))*sin(mstm(2))/sin(angles(2)))
      angles(3) = acos((cos(mstm(1))*cos(mstm(2))*cos(mstm(3)) - sin(mstm(1))*sin(mstm(3)))/sin(angles(2)))
      if (cos(mstm(2)) < 0) then 
        angles(1) = -angles(1)
      end if 
      if (cos(mstm(1))*cos(mstm(2))*sin(mstm(3)) + sin(mstm(1))*cos(mstm(3)) < 0.0) then
        angles(3) = -angles(3)
      end if 
     end if 
     


    end subroutine convert_mstm_to_ddscat


end module common_mod