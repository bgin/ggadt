module fftw
    @USE_OMP_LIB@

    use constants
    use, intrinsic :: iso_c_binding
       include '@fftw3_inc_dir@/fftw3.f'
       !include '@srcdir@/f77_wisdom.f'
    logical :: first_time = .true.
    integer(8) :: plan
    integer ::  mode = fftw_estimate
    character(len=100) :: mode_name
    character(len=100) :: plan_filename
    
contains

    subroutine set_optimization_mode(mode_name_in)
        character(len=100), intent(in) :: mode_name_in

        mode_name = mode_name_in

        select case (mode_name)
        case('estimate')
            mode = fftw_estimate
        case('patient')
            mode = fftw_patient
        case('exhaustive')
            mode = fftw_exhaustive
        case('measure')
            mode = fftw_measure
        case default
            mode = fftw_estimate 
        end select
    end subroutine set_optimization_mode



    function fft(f,x,y)
        
        real(kind=dp_real),  intent(in) :: x(:), y(:)
        complex(c_double_complex), intent(inout) :: f(:,:)
        complex(c_double_complex), dimension(size(x),size(y)) :: fft
        integer :: nx, ny
        integer :: error


        nx = size(x)
        ny = size(y)
        @OMP_UNCOMMENT@threaderror = fftw_init_threads()
        @OMP_UNCOMMENT@if (threaderror == 0) then
        @OMP_UNCOMMENT@    write (0,*) "------------------------------"
        @OMP_UNCOMMENT@    write (0,*) "Error initializing multiple threads. Program will attempt to proceed"
        @OMP_UNCOMMENT@    write (0,*) "using 1 thread."
        @OMP_UNCOMMENT@    write (0,*) "------------------------------"
        @OMP_UNCOMMENT@    numthreads = 1
        @OMP_UNCOMMENT@else
        @OMP_UNCOMMENT@    numthreads = omp_get_max_threads()
        @OMP_UNCOMMENT@endif
        @OMP_UNCOMMENT@call fftw_plan_with_nthreads(numthreads)
        !if (first_time) then
        !    error = import_wisdom_from_filename(trim(adjustl(plan_filename)))
        !    if (error == 0) then
        !        call dfftw_plan_dft_2d(plan, ny, nx, f ,fft, fftw_backward,mode)
         !       call export_wisdom_to_filename(error, plan_filename)
         !   else
         !       call dfftw_plan_dft_2d(plan, ny, nx, f ,fft, fftw_backward,mode)
         !   end if
          !  first_time = .false.
        !end if
        call dfftw_plan_dft_2d(plan, ny, nx, f ,fft, fftw_backward,mode)
        call dfftw_execute_dft(plan, f, fft)
    end function fft

    function fft_firstk(f,K)
        ! How this calculation works:
        !   Say I have 15 data points, in one dimension, for which I only care about the first 5 values of its FFT.
        !
        !   We can calculate these first five k values by doing 15/5 = 3 FFT's of length 5.
        !
        !       Original data: dddddddddddddddd
        !
        !       FFT1 = FFT( d--d--d--d--d--d )
        !       FFT2 = FFT( -d--d--d--d--d-- )
        !       FFT3 = FFT( --d--d--d--d--d- )
        !
        !       FFT(orig)(k) = sum_i(FFTi(k))*twid_factor(k)
        ! 

        integer, intent(in) :: K
        integer :: lentwids, keff, allocation_status
        integer(8) :: localplan
        complex(8), intent(inout) :: f(:,:)
        complex(8), dimension(K,K) :: fft_firstk 
        complex(8), allocatable :: small_fft(:,:), twids(:,:), fft_firstk_working(:,:)

        integer  :: N, NFFT, i,j,l,m 

        keff = k
        N = size(f(:,1))
        NFFT = N/Keff

        ! Make sure N is divisible by K.
        !    if not, we take the first K+n values of the FFT 
        !    and throw away n of them (n is the smallest integer such that K+n | N)
        do while ((.not. keff*NFFT .eq. N) .and. keff < N )
            keff = keff + 1
            NFFT = N/Keff 
        end do 

        lentwids = N

        ! allocate twids, small_fft and fft_firstk_working arrays
        !   twids               -- contain twiddle factors needed to combine the different fft calculations
        !   small_fft           -- the array in which each fft is temporarily stored
        !   fft_firstk_working  --

        allocate(twids(lentwids, lentwids), stat = allocation_status)
        if (allocation_status/=0) then
            write (0,*) " **ERROR! Cannot allocate twids array (fftwmod)"
            stop
        end if 
        allocate(small_fft(keff, keff), stat = allocation_status)
        if (allocation_status/=0) then
            write (0,*) " **ERROR! Cannot allocate small_fft array (fftwmod)"
            stop
        end if 
        allocate(fft_firstk_working(keff, keff), stat = allocation_status)
        if (allocation_status/=0) then
            write (0,*) " **ERROR! Cannot allocate fft_firstk_working array (fftwmod)"
            stop
        end if 

        do i=1,keff
            do j=1,keff
                fft_firstk_working(i,j) = 0.0D0
            end do 
        end do 

        if (Keff*NFFT .ne. N) then
            write(0,*) "ERROR: NFFT = ",NFFT," and K = ",K,", but NFFT*K = ",NFFT*K," != ",N
            stop 
        endif

        

        ! Calculate twiddle factors

        do i=0,(keff-1)
            do j=0,(keff-1)
                do l=0,(NFFT-1)
                    do m=0,(NFFT-1)
                        twids(1 + i + l*Keff, 1 + j + m*Keff ) &
                            & = zexp(CMPLX(0,1)*ISIGN*twopi*(real(i*l+j*m))/real(N))
                    end do 
                end do 
            end do 
        end do

        do l=1,NFFT
            do m=1,NFFT
                ! plan
                call dfftw_plan_dft_2d(localplan, Keff, Keff, f(l:N:NFFT,m:N:NFFT) ,small_fft, fftw_backward,mode)

                ! execute plan
                call dfftw_execute_dft(localplan, f(l:N:NFFT,m:N:NFFT), small_fft)

                ! transfer results to master array
                do i=1,Keff
                    do j=1,Keff 
                        fft_firstk_working(i,j) = fft_firstk_working(i,j) + small_fft(i,j)*twids( i+(l-1)*Keff , j+(m-1)*Keff )
                    end do 
                end do 

                ! clean up
                call dfftw_destroy_plan(localplan)
            end do 
        end do
        
        ! only get the K values that we care about
        fft_firstk = fft_firstk_working(:K,:K)

        deallocate(twids)
        deallocate(small_fft)
        deallocate(fft_firstk_working)
    end function fft_firstk

end module fftw