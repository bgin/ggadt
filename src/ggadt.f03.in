program ggadt
    use, intrinsic :: iso_c_binding
    use, intrinsic :: iso_fortran_env
    

    use sphere
    use spheres
    use ellipsoid
    use common_mod

    @USE_OMP_LIB@
    @USE_FFTW@
    @USE_GPFA@

    implicit none

    
    real, allocatable :: x(:), y(:), kx(:), ky(:), thetax(:), thetay(:)
    complex(c_double_complex), allocatable :: sh(:,:), ftsh(:,:), ftsh_firstK(:,:)
    real, allocatable :: chrd(:,:), scatter(:,:), scatter_temp(:,:)

    real :: xmin, xmax, ymin, ymax, dx, dy, k, l, thetamax, convang, dk
    real, dimension(3) :: eul_ang
    real, dimension(3,3) :: rm 
    integer :: i, j, q, neul, allocatestatus, deallocatestatus, num_args, nangle_new, klen, kactual, kmin, kmax, enhancement


    
    klen = 25
    

    call set_parameter_values()
    call initialize_and_allocate_vars()
    @FFTW3_UNCOMMENT@call set_optimization_mode(fftw_optimization_mode_name)
    if ( verbose_mode ) call print_parameters()


    if (use_experimental_fft) then
        thetamax = 3000.
        convang = (360.*60.*60.)/(2*pi)


        call get_fft_vals(-thetamax/convang,thetamax/convang,klen,kmin,kmax,enhancement,kactual)


        allocate(kx(kactual),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (kx) ***"
        allocate(ky(kactual),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (ky) ***"
        allocate(thetax(kactual),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (thetax) ***"
        allocate(thetay(kactual),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (thetay) ***"

        dk = real(kmax-kmin)/real(size(kx) - 1)
        do i=1,size(kx)
            kx(i) = ((i-1)*dk + kmin)*(TWOPI/L)
            ky(i) = kx(i)

            thetax(i) = asin(kx(i)/k)
            thetay(i) = asin(ky(i)/k)
        end do
    end if 
    if (geometry .eq. "sphere") then
        !$omp parallel shared(sh,x,y,zmax,k) 
        !$omp do schedule(dynamic) private(i,j)
        do i=1,size(x)
            do j=1,size(y)
                sh(i,j) = shadow_sphere(x(i),y(j),k,a_eff,delm)
            end do
        end do
        !$omp end do nowait
        !$omp end parallel
        if (use_experimental_fft) then

            !ftsh = fft_center(ftsh)
            ftsh = experimental_fft(sh,kmin,kmax,enhancement)
            !write (0,*) "TESTING FIRST K"
            !do i=1,klen
            !    do j=1,klen
            !        write (0,*) "(",i,",",j,") fft_firstK = ",ftsh_firstK(i,j),"| ftsh = ",ftsh(i,j)
            !    end do 
            !end do 
            !stop
        else
            sh = fft_center(sh)
            ftsh = fft(sh,x,y)
            
        endif
        !stop
        !$omp parallel shared(scatter,ftsh,k,dx,dy) 
        !$omp do schedule(dynamic) private(i,j)
        do i=1,size(thetax)
            do j=1,size(thetay)
                scatter(i,j) = scatter(i,j) + abs((k*ftsh(i,j)*dx*dy))**2/(4*pi*(pi*a_eff)**2)
            end do
        end do
        !$omp end do nowait
        !$omp end parallel
    else
        do neul = 1,nangle
            eul_ang = get_new_euler_angles(neul)
            rm = matmul(matmul(rot_x(eul_ang(1)), rot_y(eul_ang(2))),rot_z(eul_ang(3)))
            

            if (geometry .eq. 'ellipsoid') then 
                !$omp parallel shared(sh,x,y,rm,k) 
                !$omp do schedule(dynamic) private(i,j)
                do i=1,size(x)
                    do j=1,size(y)
                        sh(i,j) = shadow_ellipsoid(x(i),y(j), k,grain_a,delm,rm )
                    end do
                end do
                !$omp parallel shared(sh,x,y,rm,k) 
                !$omp do schedule(dynamic) private(i,j)
            end if 

            if (geometry .eq. 'spheres')    then
                sh = shadow_spheres(x,y,k,rm)
            end if 

            if (use_experimental_fft) then
                !TEST ftsh = experimental_fft(sh,x,y) 
                ftsh = fft(sh,x,y)
                ftsh = fft_center(ftsh)
            else
                ftsh = fft(sh,x,y)
                ftsh = fft_center(ftsh)
            endif

            !$omp parallel shared(scatter,ftsh,k,dx,dy) 
            !$omp do schedule(dynamic) private(i,j)
            do i=1,size(x)
                do j=1,size(y)
                    scatter(i,j) = scatter(i,j) + abs((k*ftsh(i,j)*dx*dy))**2/(4*pi*(pi*a_eff)**2)/real(nangle)
                end do
            end do
            !$omp end do nowait
            !$omp end parallel


            write(0,fmt="(a1,a,t21,f6.2,a)",advance="no") achar(13), &
                    & " percent complete: ", (real(neul)/real(nangle))*100.0, "%"
        end do
    end if 
 

    if (timing_mode) stop 

    print *, "# [thetax] [thetay] [dqscat/domega]"
    
    do i=1,size(thetax)
        do j=1,size(thetay)
            print *,thetax(i),thetay(j),scatter(i,j)
        end do
    end do
    if (verbose_mode) write(0,*) "done."

    call cleanup()

contains

    function get_k(x)
        implicit none
        real, intent(in) :: x(:)
        integer :: n, i, j 
        real :: l
        real, dimension(size(x)) :: get_k
        n = size(x)
        l = x(n) - x(1)
        do i=1,n
            get_k(i) = (2*pi/l)*(real(i-1)/real(n) - 0.5)
        end do
    end function get_k

    subroutine initialize_and_allocate_vars()
        implicit none 
     integer :: line, status
      character(len=100) :: junk
        allocate(x(ngrid),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (x) ***"
        allocate(y(ngrid),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (y) ***"
        if (.not. use_experimental_fft) then
            allocate(kx(ngrid),stat = allocatestatus)
            if (allocatestatus /= 0) stop "*** not enough memory (kx) ***"
            allocate(ky(ngrid),stat = allocatestatus)
            if (allocatestatus /= 0) stop "*** not enough memory (ky) ***"
            allocate(thetax(ngrid),stat = allocatestatus)
            if (allocatestatus /= 0) stop "*** not enough memory (thetax) ***"
            allocate(thetay(ngrid),stat = allocatestatus)
            if (allocatestatus /= 0) stop "*** not enough memory (thetay) ***"
        end if
        allocate(sh(ngrid,ngrid),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (sh) ***"
        allocate(ftsh(ngrid,ngrid),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (ftsh) ***"
        allocate(ftsh_firstK(klen,klen),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (ftsh_firstK) ***"
        allocate(chrd(ngrid,ngrid),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (chrd) ***"
        allocate(scatter(ngrid,ngrid),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (scatter) ***"
        allocate(scatter_temp(ngrid,ngrid),stat = allocatestatus)
        if (allocatestatus /= 0) stop "*** not enough memory (scatter_temp) ***"

        if (euler_angle_mode == 'sequential') then
            nangle_new = int(real(nangle)**(1.0/3.0))**3
            if (nangle /= nangle_new) then
                write (error_unit,*) ""
                write (error_unit,*) "   + nangle: ",nangle,"-->",nangle_new
                nangle = nangle_new
            endif
        else if (euler_angle_mode == 'random') then
            call init_random_seed()

        else if (euler_angle_mode == 'file') then 
            if (euler_angle_file == "") then
              write(0,*) "ERROR: euler_angle_mode of 'file', but specified file is empty"
              stop
            else
              line = 0
              open(10,file=euler_angle_file,iostat=status)
              if (status .ne. 0)then 
                write(0,*) "ERROR: euler_angle_file of ",euler_angle_file," does not exist."
                stop
              else
              do while(status == 0)
                read(10,'(A)',iostat=status) junk
                if (status == 0) line = line+1
              end do 
              if (line .ne. nangle) then
                if (line == 0) then
                    write(0,*) "ERROR: No orientations found in ", euler_angle_file,"!"
                    stop
                end if 
                write(0,*) "WARNING: nangle set to ",nangle," but there are ",line," orientations in ",&
                  euler_angle_file,". nangle -> ",line
                nangle = line 
              end if

              end if
              close(10) 
            end if 
        else 
            write(error_unit,*) " ***error: do not understand euler_angle_mode=",euler_angle_mode
            stop
        end if 

        if ((geometry == 'sphere') .or. (geometry == 'spheres')) then 
            if (geometry == 'spheres') then
                default_ior_i = ior_im
                default_ior_r = ior_re
                call read_spheres(cluster_file_name, a_eff)
                
            end if 
            grain_a(1) = a_eff 
            grain_a(2) = a_eff
            grain_a(3) = a_eff
        else if (geometry == 'ellipsoid') then
            l = a_eff/((grain_a(1)*grain_a(2)*grain_a(3))**(1.0/3.0))
            ! normalize so that grain_a(1), (2), (3) produce an ellipse with an effective
            ! radius of a_eff
            grain_a(1) = grain_a(1)*l
            grain_a(2) = grain_a(2)*l
            grain_a(3) = grain_a(3)*l
        else
            write(0,*) "ERROR: cannot understand ", geometry
            stop
        end if 
        

        k = (2*pi/1.239842)*1000*ephot



        xmin = -grid_width*a_eff/2.0
        ymin = -grid_width*a_eff/2.0
        xmax = grid_width*a_eff/2.0
        ymax = grid_width*a_eff/2.0

        dx = (xmax-xmin)/(size(x)-1)
        dy = (ymax-ymin)/(size(y)-1)

        

        do i=1,size(x)
            x(i) = xmin + (i-1)*dx
        end do
        do i=1,size(y)
            y(i) = ymin + (i-1)*dy
        end do

        L = x(size(x)) - x(1)
        if (.not. use_experimental_fft) then
            kx = get_k(x)
            ky = get_k(y)
            do i=1,size(kx)
                thetax(i) = asin(kx(i)/k)
                thetay(i) = asin(ky(i)/k)
            end do      
        end if 
    end subroutine initialize_and_allocate_vars

    subroutine init_random_seed()
        use, intrinsic :: iso_fortran_env
        implicit none

        integer, allocatable :: seed(:)
        integer(4) :: i, n, un, istat, dt(8), pid, t(2), s
        integer(kind=1) :: getpid
        integer(8) :: count, tms

        call random_seed(size = n)
        allocate(seed(n))
        ! first try if the os provides a random number generator
        !open(un, file="/dev/urandom", access="stream", &
        !     form="unformatted", action="read", status="old", iostat=istat)
        istat = 1
        if (istat == 0) then
           read(un) seed
           close(un)
        else
           ! fallback to xor:ing the current time and pid. the pid is
           ! useful in case one launches multiple instances of the same
           ! program in parallel.
           call system_clock(count)
           if (count /= 0) then
              t = transfer(count, t)
           else
              call date_and_time(values=dt)
              tms = (dt(1) - 1970) * 365_8 * 24 * 60 * 60 * 1000 &
                   + dt(2) * 31_8 * 24 * 60 * 60 * 1000 &
                   + dt(3) * 24 * 60 * 60 * 60 * 1000 &
                   + dt(5) * 60 * 60 * 1000 &
                   + dt(6) * 60 * 1000 + dt(7) * 1000 &
                   + dt(8)
              t = transfer(tms, t)
           end if
           s = ieor(t(1), t(2))
           !pid = GETPID() + 1099279 ! add a prime
           pid = 1099279
           s = ieor(s, pid)
           if (n >= 3) then
              seed(1) = t(1) + 36269
              seed(2) = t(2) + 72551
              seed(3) = pid
              if (n > 3) then
                 seed(4:) = s + 37 * (/ (i, i = 0, n - 4) /)
              end if
           else
              seed = s + 37 * (/ (i, i = 0, n - 1 ) /)
           end if
        end if
        call random_seed(put=seed)
    end subroutine init_random_seed

    function get_new_euler_angles(i)
        real, dimension(3) :: get_new_euler_angles
        integer, intent(in) :: i
        integer                :: j 
        character(len=50)    :: junk
        integer :: cbrt_nangle, nx, ny, nz


        if (euler_angle_mode .eq. 'sequential') then 
            cbrt_nangle = int(nangle**(1.0/3.0))
            nx = mod(i/(cbrt_nangle*cbrt_nangle),   cbrt_nangle)
            ny = mod(i/(cbrt_nangle),               cbrt_nangle)
            nz = mod(i,                             cbrt_nangle) 
            get_new_euler_angles(1) = 2*pi*(nx-1)/cbrt_nangle
            get_new_euler_angles(2) = 2*pi*(ny-1)/cbrt_nangle
            get_new_euler_angles(3) = 2*pi*(nz-1)/cbrt_nangle
        else if ( euler_angle_mode .eq. 'file' ) then
            open(unit=1,file=euler_angle_file)
            if (i > 1) then 
                do j=1,i-1
                    read(1,'(A)') junk
                end do
            end if 
            read(1,*) get_new_euler_angles
            close(1)
        else
            call random_number(get_new_euler_angles)
            get_new_euler_angles(1) = 2*pi*get_new_euler_angles(1)
            get_new_euler_angles(2) = 2*pi*get_new_euler_angles(2) 
            get_new_euler_angles(3) = 2*pi*get_new_euler_angles(3)
        endif
    end function get_new_euler_angles

    subroutine cleanup()
        deallocate(x,stat=deallocatestatus)
        deallocate(y,stat=deallocatestatus)
        deallocate(kx,stat=deallocatestatus)
        deallocate(ky,stat=deallocatestatus)
        deallocate(thetax,stat=deallocatestatus)
        deallocate(thetay,stat=deallocatestatus)
        deallocate(sh,stat=deallocatestatus)
        deallocate(ftsh,stat=deallocatestatus)
        deallocate(scatter,stat=deallocatestatus)
        deallocate(scatter_temp,stat=deallocatestatus)
        deallocate(chrd,stat=deallocatestatus)


        if (geometry .eq. 'spheres')    then
            deallocate(pos)
            deallocate(pos_rot)
            deallocate(radii)
            deallocate(ior_r)
            deallocate(ior_i)
        end if

    end subroutine cleanup

    subroutine get_fft_vals(thetamin,thetamax,Kask,kmin,kmax,enhancement,Kout)
        real, intent(in) :: thetamin, thetamax
        integer, intent(in) :: Kask
        integer, intent(out) :: kmin,kmax,enhancement, Kout


        !write (0,*) "thetamin, thetamax, Kask",thetamin,thetamax, Kask  

        enhancement = 1

        write(0,*) "K,l = ",k,l

        kmin = int(floor(k*sin(thetamin)*(L/TWOPI)))
        kmax = int(ceiling(k*sin(thetamax)*(L/TWOPI)))

        Kout = kmax - kmin

        do while (enhancement*Kout + 1 < Kask) 
            enhancement = enhancement+1
        end do 

        Kout = enhancement*Kout + 1

        !write(0,*) "kmin,kmax,kout",kmin,kmax,kout 

    end subroutine get_fft_vals

    subroutine print_parameters()
        write(0,*) "Parameter values:"
        write(0,*) "-----------------------------------"
        write(0,*) "delm:",delm
        write(0,*) "ephot:",ephot
        write(0,*) "geometry:", geometry
        write(0,*) "euler_angle_mode:",euler_angle_mode
        if (euler_angle_mode == "file") write(0,*) "euler_angle_file:", euler_angle_file

        write(0,*) "ngrid:",ngrid
        write(0,*) "nangle:",nangle
        write(0,*) "grid-width:",grid_width
        write(0,*) "ior_re:",ior_re
        write(0,*) "ior_im",ior_im
        write(0,*) "grain_axes:",grain_a
        write(0,*) "use_experimental_fft:",use_experimental_fft
        if (verbose_mode) write(0,*) "(verbose mode)"
        if (timing_mode) write(0,*) "(timing mode)"

        write(0,*) "parameter_file_name:",parameter_file_name
        write(0,*) "fftw_optimization_mode_name:",fftw_optimization_mode_name
        if (geometry == "spheres") write(0,*) "cluster_file_name:",cluster_file_name
        write(0,*) "-----------------------------------"

    end subroutine print_parameters

    

end program ggadt

